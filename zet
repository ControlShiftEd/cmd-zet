#!/usr/bin/bash
# shellcheck disable=SC2016
set -e
#export PATH="/usr/bin:/usr/local/bin"

# Copyright 2021 Rob Muhlestein <rob@rwx.gg>
# Released under Apache-2.0 license
# Please mention https://youtube.com/rwxrob

(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1

EXE="${0##*/}"

declare -A help # associative arrays *require* declaration

: "${PAGER:=more}"
: "${EDITOR:=vi}"
: "${HELP_BROWSER:=}"
: "${GITUSER:=$USER}"
: "${GITBRANCH:=main}"
: "${ZETDIR:=$HOME/.local/share/zet}"
: "${ZETCASTDIR:=$HOME/Videos/ZettelCasts}"
[[ -n "$KN" ]] && ZETDIR="$KN"

EXE=${0##*/}
[[ -z "$EXE" ]] && echo "Could not determine name of executable." && exit 1
DIR="$ZETDIR/$EXE"

# ------------------------- utility functions ------------------------

_newest() {
  IFS=$'\n'
  local -a f=($(ls -1 --color=never -trd ${1:-.}/* 2>/dev/null))
  [[ ${#f} > 0 ]] && echo "${f[-1]}"
}

# ----------------------------- commands -----------------------------

help[main]='
The `zet` command is a multicall executable bash script for managing one
or more
[Zettelkasten](https://github.com/rwxrob/zet/search?q=Zettelkasten) git
repos.

## Usage

In place of `<zet>` the word `last` can be used instead as well as any
path to the `README.md` file or the "zet cast" YouTube video identifier
(the id or URL, if it has one).

```
zet usage
zet help [<command>]
zet (a[dd])           - create new zettel dir and open with editor
zet after <zettel>    - print id of first zettel after <zetid>
zet before <zettel>   - print id of first zettel before <zetid>
zet body <zettel>     - print zettel body
zet commit <zettel>   - git commit zettel with title as message
zet dir               - print zettelkasten repo directory path
zet each              - iterate over each zettel


zet title <zetid>     - print zettel title

```

## Dependencies

The `zet` script requires Bash 4.0 (or above) and depends on the
following commands not normally installed by default:

* `yt`
* `pandoc`
* `curl`
* `jq`
* `auth`

## Environment

* `EDITOR`
* `GITUSER`
* `HELP_BROWSER`
* `KN`
* `ZETDIR`

## Completion

Add the following to bashrc to enable completion (replacing zet with
your multicall executable name):

    complete -C zet zet

Note that you will need one such complete line for every multicall
variation of this script:

    ln -s zet log
    complete -C log log

## Filter Commands

True to the UNIX philosophy, most all commands can either take an
argument or will read from standard input recursively calling the same
command once for each line of input allowing commands to be called from
within Ed/Vim sessions as well as from the command line in pipeline
form.

## Path to Zettelkasten Directory

Checks for `$ZETDIR` or `$KN` variables (in that order). If found, use
those variables for the parent directory. If they do not exist, check
for the existance of the default directory and create the folder if
necessary. This not only allows for customization of the parent
directory via `$ZETDIR`, but also allows for compatibility with the
KEG/KN toolset. This directory is expected to contain one or more
subdirectories, each of which is usually a git repository that directly
matches the name of the multicall executable (ex: `$ZETDIR/zet`).
'

x_usage() {
    local cmds="${COMMANDS[*]}"
    printf "usage: %s (%s)\n" "${0##*/}" "${cmds// /|}"
}


help[cast]='
The `cast` command combines video and audio recording with the
creation of a new zettel repo. The zettel it creates includes reminders
to start recording and about the preferred content order for such
videos.  '

_cast_last() {
    _newest "$ZETCASTDIR/Pending"
}

_cast_pending() {
  case $1 in
    prep) shift; _cast_pending_prep "$@"; return $?;;
    dir) shift; _cast_pending_dir "$@"; return $?;;
  esac
	find "$ZETCASTDIR/Pending" -type f | sort
}

_cast_pending_prep() {
	for i in $(_cast_pending); do
    if [[ $i =~ [0-9]{14,}.mkv ]]; then
      echo Skipping $i
      continue
    fi
    local zetid
    zetid=$(x_for "$i")
    echo "$i -> $zetid.mkv" 
		mv "$i" "$ZETCASTDIR/Pending/$zetid.mkv"
	done
}

_cast_pending_dir() {
  echo "$ZETCASTDIR/Pending"
}

x_cast() {
    case "$1" in
        last) shift; _cast_last "$@"; return $?;;
        pending) shift; _cast_pending "$@"; return $?;;
    esac
    local topic
    if type iam &>/dev/null; then
        topic="$(topic)"
        type iam &>/dev/null && iam recording "$*"
    fi
    local zetid=$(x_isosec)
    mkdir "/tmp/$zetid"
    echo -e "# $*\n\n*remember to start recording*\n\n1. Scenario\n2. Solution\n3. Steps\n4. Summary\n" > "/tmp/$zetid/README.md"
    local zetid
    zetid=$(x_import "/tmp/$zetid")
    (( $? == 0 )) && rm -rf "$zetid"
    x_edit "$zetid"
    if [[ -n "$topic" ]]; then
        t "$topic"
    fi
    _cast_pending_prep
}

help[import]='
The `import` command copies an exactly duplicate of the directory passed
as the first argument. The first argument is assumed to be a unique
zettel identifier (isosec). (Note that in the extemely unlikely event that an identifier conflicts, the import will fail.)
'

x_import() {
    _filter "$@" && return $?
    local dir="$(x_dir)"
    [[ ! -d "$1" ]] && return 1
    mv "$1" "$dir"
    x_commit "${1##*/}" &>/dev/null
    echo "${1##*/}"
}

help[delete]='
The `delete` command removes the indicated zettel directory from the zet repo and directory, and commits and pushes the removal. The word "last" can be used instead of a zettel identifier for convenience.'

x_delete() {
    _filter "$@" && return $?
    local dir="$(x_dir)"
    local zetid="$1"
    [[ $zetid = last ]] && zetid=$(x_last)
    if [[ ! -d "$dir/$zetid" ]]; then
        echo "Does not exist '$zetid'"
        return 1
    fi
    rm -rf "$dir/$zetid"
    echo "Removed $dir/$zetid"
    cd "$dir" &>/dev/null
    git add -A "$dir/$zetid" &>/dev/null
    git commit -m "Deleted $zetid" &>/dev/null || true
    git push &>/dev/null
    cd - &>/dev/null
}

help[each]='

**Not yet implemented.**

The `each` command reads the arguments as a template for a command to be
passed to the command line. The syntax of the template uses Go templates
(as popularized by Kubernetes). The following values can be wrapped in
double curly brackets to be replaced before being called. If a value is
empty the word `null` will be replaced. By default, all markdown is
converted into text with the pandoc command:

|Value|Description|
|-|-|
`{{.ID}}`|isosec identifier
`{{.Title}}`|full (converted) text of title
`{{.Body}}`|all text (converted) but title and video
`{{.Slug}}`|dashed slug derived from title
`{{.Video}}`|full video URL (usually https://youtu.be/...)
`{{.File.Dir}}`|full path to the zettel directory
`{{.File.README}}`|full path to the README.md file
`{{.File.Data}}`|full path to the data.yaml file (even if not exists)
`{{.Web.Dir}}`|curl-able URL to the zettel directory
`{{.Web.README}}`|curl-able URL to raw README.md file
`{{.Web.Data}}`|curl-able URL to raw data.yaml file
`{{.Data.*}}`|reference to data from the parsed data.yaml file
`{{.Raw.Title}}`|raw markdown of title (including initial #)
`{{.Raw.Body}}`|raw markdown of body
`{{.Raw.README}}`|raw markdown entire README.md file
`{{.Raw.Data}}`|raw YAML from data.yaml file

The order is always sorted by isosec meaning that the newest will
always be last.
'

x_each() {
  if [[ $# == 0 ]];then
    x_each "echo"
    return 0
  fi
  local dir
  dir=$(x_dir)
  for i in $(x_ids); do
    "$@" "$dir/$i/README.md"
  done
}

help[grep]='
The `grep` command simply a shortcut for `zet each grep "$@"` running
the system grep on all the main zettel README.md files passing the
arguments as-is to the grep command (-P for PCRE, etc.)
'

x_grep() { x_each grep "$@"; }

x_open() {
  local zetid="$1"
  [[ -z "$zetid" || $zetid = last ]] && zetid=$(x_last)
  open "https://github.com/$GITUSER/zet/tree/main/$zetid"
}

help[help]='
The `help` command prints help information. If no argument is passed
displays general help information (main). Otherwise, the documentation
for the specific argument keyword is displayed, which usually
corresponds to a command name (but not necessarily). All documentation
is written in CommonMark (Markdown) and will displayed as Web page if
`pandoc` and `$HELP_BROWSER` are detected, otherwise, just the Markdown is
sent to `$PAGER` (default: more).'

x_help() { 
  local name="$1"
  if [[ -z "$name" ]];then
    for c in "${COMMANDS[@]}";do
      x_help "$c" buildonly
    done
    x_help main
    return 0
  fi
  local title="$EXE $name"
  [[ $name = main ]] && title="$EXE"
  local file="/tmp/help-$EXE-$name.html"
  local help="${help[$name]}\n"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" && [[ -t 1 ]] ;then
      pandoc -s --metadata title="$title" \
        -o "$file" <<< "$help"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -s --metadata title="$title" \
      -t plain <<< "$help" | "$PAGER"
    return 0
  fi
  echo "$help" | "$PAGER"
}

x_commit() {
  _filter "$@" && return $?

  # if no zet, bail
  local dir
  dir="$(x_dir)/$1"
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "<not found: $1>" && return 1

  # git commit keeping title as commit message 
  local title
  title=$(x_title "$1")
  cd "$dir" &>/dev/null
  git add -A "$dir" &>/dev/null
  git commit -m "$title" &>/dev/null || true
  git push &>/dev/null
  echo Commited.
  cd - &>/dev/null

}

x_yt() {
  _filter "$@" && return $?

  # accept zet or yt ids  
  local zetid ytid changed
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    zetid="$1"
    ytid="${2##*/}"
  elif [[ $1 = last ]]; then
    zetid=$(x_last)
    ytid="${2##*/}"
  else
    ytid="${1##*/}"
    zetid=$(yt zet "$1")
  fi

  # if no zet, bail
  local dir readme
  dir="$(x_dir)/$zetid"
  readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "<not found: $zetid/$ytid>" && return 1

  # if zet has vid line...
  if [[ $(sed '3q;d' "$readme") =~ ^ðŸ“º\ \<https://youtu.be/(.*)\> ]]; then

    # update if ytid 
    if [[ -n "$ytid" ]]; then
      echo -e "3c\nðŸ“º <https://youtu.be/$ytid>\n.\nwq" | ed "$readme" >/dev/null
      changed=1

    # read it to print later
    else
      ytid=${BASH_REMATCH[1]}
    fi

  # zet does not have vid line
  else

    # so add it if have video id
    if [[ -n "$ytid" ]]; then
      echo -e "2a\nðŸ“º <https://youtu.be/$ytid>\n\n.\nwq" | ed "$readme" >/dev/null
      changed=1
    fi
  fi

  # always print the url to the video id
  if [[ -n "$ytid" ]]; then
    echo "https://youtu.be/$ytid"
    [[ $changed = 1 ]] && x_commit "$zetid"
  else
    echo "<no video found in $zetid>"
  fi
}

x_urlencode() {
  _filter "$@" && return $?
  local string="$*"
  local strlen=${#string}
  local encoded=""
  local pos c o
  for ((pos = 0; pos < strlen; pos++)); do
    c=${string:$pos:1}
    case "$c" in
    [-_.~a-zA-Z0-9]) o="${c}" ;;
    *) printf -v o '%%%02x' "'$c'" ;;
    esac
    encoded+="${o}"
  done
  echo "${encoded}"
}

x_isosec() { date -u +%Y%m%d%H%M%S "$@"; }
x_isonan() { date -u +%Y%m%d%H%M%S%N "$@"; }
x_dir() { [[ -d $DIR ]] && echo "$DIR"; }

help[create]='
The `create` command creates a Zettel directory with an isosec unique
name within the `$ZETDIR` parent directory.  It then opens the `$EDITOR`
(if set) or `vim`. After the edits are complete prompts to commits the
repo with `git commit` using the first 50 characters of the first line
as the commit message (ignoring heading hashtags if prefixed) and
pushes.'

x_create() {
  local title="$*"
  local dir readme
  dir="$(x_dir)/$(x_isosec)"
  readme="$dir/README.md"
  mkdir -p "$dir"
  printf "# %s\n\n" "$title" > "$readme"
  "${EDITOR:-vim}" "$readme"
  cd "$dir" &>/dev/null
  [[ -s "$dir/README.md" ]] || return 1
  line=$(head -1 "$dir/README.md" | sed 's/#\+ *//')
  test -n "$line"
  echo "Committing: $line"
  git add -A "$dir" &>/dev/null
  git commit -m "$line" &>/dev/null
  git push &>/dev/null
}

x_edit() {
  local dir zetid
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    zetid="$1"
    dir="$(x_dir)/$1"
  elif [[ $1 = last ]]; then
      zetid="$(x_last)"
    dir="$(x_dir)/$zetid"
  else
    zetid=$(yt zet "$1")
    if [[ -z "$zetid" ]]; then
      echo "Unable to determine zet id for $1"
      return 1
    fi
    dir="$(x_dir)/$zetid"
  fi
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "Not found." && return 1
  "${EDITOR:-vim}" "$readme"
  read -r -p "Commit? " resp
  [[ $resp =~ ^[yY] ]] && x_commit "$zetid"
}

x_titles() {
  local dir buf title
  local -a zets
  dir=$(x_dir)
  mapfile zets < <(find "$dir" -maxdepth 2 -type d -path '*/2*'|sort)
  for i in "${zets[@]}"; do
    i=${i%[[:space:]]*}
    [[ -r "$i/README.md" ]] || continue
    title=$(head -1 "$i/README.md")
    [[ $title =~ ^#\  ]] || title="<untitled>"
    title="${title#*# }"
    buf="$buf${i##*/} ${title#*# }  "$'\n'
  done
  pandoc -t plain --wrap=none <<< "$buf"
}

x_last() {
  local last count="${1:-1}"
  mapfile titles < <(x_titles)
  last=${#titles[@]}
  for (( i=count; i>0; i-- )); do
    echo "${titles[$last-$i]%% *}"
  done
}

x_text() {
  _filter "$@" && return $?
  local dir readme
  dir="$(x_dir)/$1"
  readme="$dir/README.md"
  [[ -r $readme ]] || return 1
  command -v pandoc &>/dev/null \
    || (echo "'$EXE text' requires pandoc" && return 1)
  pandoc -t plain --wrap=none < "$readme"
}

x_title() {
  _filter "$@" && return $?
  local dir readme title
  dir="$(x_dir)/$1"
  [[ -d $dir ]] || return 1
  readme="$dir/README.md"
  read -r title < "$readme"
  [[ ! $title =~ ^#\  ]] && return 1
  pandoc -t plain --wrap=none <<< "${title#\# }"
}

x_body() {
  _filter "$@" && return $?
  local dir readme title buf eol
  dir="$(x_dir)/$1"
  [[ -d $dir ]] || return 1
  readme="$dir/README.md"
  buf=$(<"$readme")
  eol=$'\n'
  [[ $buf =~ ^\#\  ]] && buf=${buf#*$eol$eol} 
  buf=${buf#ðŸ“º *$eol$eol}
  pandoc -t plain --wrap=none <<< "$buf"
}

x_query() {
  _filter "$@" && return $?
  [[ -z "$1" ]] && echo "Missing search query." && return 1
  term="$*"
  it="https://github.com/$GITUSER/$EXE/search?q=$(x_urlencode "$term")"
  echo "[$term]: <$it>"
  command -v chat &>/dev/null && chat "$it"
}

x_ids() {
  while read -r line; do
    echo "${line##*/}"
  done < <(find "$(x_dir)" -maxdepth 2 -type d -path '*/2*'| sort)
}

help[before]='
The `before` command prints the zet id of the first zettel immediately
preceeding the one passed as an argument. This command can be called as
a filter.'

x_before() {
  _filter "$@" && return $?
  local prev
  while read -r cur; do
    (( cur > id )) && break
    prev=$cur
  done < <(x_ids)
  echo "$prev"
}

x_for() {
  _filter "$@" && return $?
  local mkv id
  mkv="$1"
  [[ $mkv == last ]] && mkv=$(mkvlast)
  [[ $mkv =~ - ]] && mkv=$(mkv2isosec "$mkv")
  id=${mkv##*/}
  id=${id%.mkv}
  x_before "$id"
}

help[after]='
The `after` command prints the zet id of the first zettel immediately
following the one passed as an argument. This command may be called as
a filter.'

x_after() {
  _filter "$@" && return $?
  local id="$1"
  while read -r cur; do
    (( cur > id )) && break
  done < <(x_ids)
  echo "$cur"
}

help[id]='
The `id` command prints the isosec identifier derived from the passed
argument:

1. If already an isosec and zet exists, print argument
2. If `last`, delegate to `zet last`
3. If isosec match found (`2[0-9]{13,}`), print match
4. If YouTube id or URL, delegate to `yt zet`

This command may be called as a filter.
'

x_id() {
    _filter "$@" && return $?
    echo would id
}

# --------------------- completion and delegation --------------------

_have(){ type "$1" &>/dev/null; }

_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_filterbuf() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x_ ]] || continue
  COMMANDS+=( "${line##declare -f x_}" )
done < <(declare -F)

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" && ${c:0:1} != _ ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x_$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare cmd="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
      "x_$cmd" "$@"
      exit $?
    fi
  done
fi

x_usage "$@"
